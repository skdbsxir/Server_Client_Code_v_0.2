#include <iostream>
#include <stdio.h>
#include <string>

using namespace std;

void BruteMatching(string &, string &);
void FindFailFunction(string &, int[]);
void KMPMatch(string &, string &);

int main() {
	int T_size, P_size;
	scanf_s("%d%d", &T_size, &P_size);

	//문자열의 크기나 패턴의 크기를 기준보다 크게 입력한경우 종료시킨다.
	if ((T_size > 1000000) || (P_size > 100)) {
		cout << "Out of Range. Start Again.\n" << endl;
		return 0;
	}
	//패턴의 크기가 문자열의 크기보다 클 경우 종료시킨다.
	if (P_size > T_size) {
		cout << "Wrong Size Value.\n" << endl;
		return 0;
	}

	string T, P;
	cin >> T;
	cin >> P;

	int sizeT = T.length();
	int sizeP = P.length();

	//작성한 문자열 또는 패턴이 앞에서 입력한 길이보다 더 입력된 경우 종료시킨다.
	if ((sizeT > T_size) || (sizeP > P_size)) {
		cout << "Wrong String Size.\n" << endl;
		return 0;
	}

	BruteMatching(T, P);
	KMPMatch(T, P);

	system("pause");
}

void BruteMatching(string &T, string &P) {
	int Tsize = T.length();
	int Psize = P.length();
	bool matched = true;
	int i, j, count_number = 0, match_number = 0;

	for (i = 0; i < Tsize - Psize + 1; i++) {
		matched = true;
		for (j = 0; j < Psize; j++) {
			count_number++;
			if (T[i + j] != P[j]) {
				matched = false;
				break;
			}
		}
		if (matched == true)
			match_number++;
	}
	cout << match_number << " " << count_number << endl;
}

void FindFailFunction(string &P, int f[]) {
	int m = P.length(), k;
	f[0] = 0;
	for (int i = 1; i < m; i++) {
		k = f[i - 1];
		while (k >= 0) {
			if (P[k] == P[i]) {
				break;
			}
			else {
				if (f[k] == k)
					k = k - 1;
				else
					k = f[k];
			}
		}
		f[i] = k + 1;
	}
	f[0] = -1;
}

void KMPMatch(string &T, string &P) {

	int PLength = P.length();
	int TLength = T.length();
	int *f = new int[PLength];         //입력받는 패턴 P의 길이를 모르므로, 메모리의 효율성을 위해 동적으로 크기를 할당받는다.
	FindFailFunction(P, f);
	int i = 0, k = 0;
	int count_number = 0, match_number = 0;

	while (i <= TLength - PLength) {
		if (T[i + k] == P[k]) {
			count_number++;
			k++;
			if (k == PLength) {
				i = i + k - f[k - 1];
				k = f[k - 1];
				match_number++;
			}
		}
		else {							//예외처리부분.
			count_number++;
			if (f[k - 1] > 0) {
				i = i + f[k - 1];
			}
			else {
				i = i + 1;
			}

			if (k - 1 >= 0) {
				k = f[k - 1];
			}
			else
				k = 0;
			if (k == -1) {
				k = 0;
			}
		}
	}
	delete[] f;
	cout << match_number << " " << count_number << endl;
}
